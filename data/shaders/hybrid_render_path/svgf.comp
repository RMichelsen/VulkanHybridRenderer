#version 460
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_nonuniform_qualifier : require
#extension GL_EXT_shader_image_load_formatted : require
#include "../common.glsl"

layout(local_size_x = 8, local_size_y = 8) in;

layout(set = 1, binding = 0) uniform image2D storage_images[];

layout(set = 2, binding = 0) uniform PFD { PerFrameData pfd; };
layout(set = 3, binding = 0, r16f) readonly uniform image2D reprojected_uv_and_object_id;
layout(set = 3, binding = 1, r16f) readonly uniform image2D normal_texture;
layout(set = 3, binding = 2, r16f) readonly uniform image2D raytraced_shadows;
layout(set = 3, binding = 3, r16f) writeonly uniform image2D denoised_raytraced_shadows;

layout(push_constant) uniform PushConstants {
	int prev_frame_reprojection_uv_and_object_id;
	int prev_frame_object_space_normals;
	int prev_frame_raytraced_shadows;
	int integrated_raytraced_shadows;
} pc;

bool is_valid_reprojection(ivec2 prev_coords, int current_object_id, vec4 current_normal) {
	// Reject if object ID has changed
	int prev_object_id = int(imageLoad(storage_images[pc.prev_frame_reprojection_uv_and_object_id], prev_coords).z);
	if(current_object_id == -1.0 || current_object_id != prev_object_id) {
		return false;
	}

	// Reject if normals aren't aligned
	// Merge metric from [Kerzner and Salvi 2014]
	vec4 prev_normal = imageLoad(storage_images[pc.prev_frame_object_space_normals], prev_coords);
	if(dot(current_normal, prev_normal) < cos(3.14519 / 4.0)) {
		return false;
	}

	return true;
}

void main() {
	ivec2 coords = ivec2(gl_GlobalInvocationID.xy);
	vec4 current_normal = imageLoad(normal_texture, coords);
	vec4 reprojuv_and_obj_id = imageLoad(reprojected_uv_and_object_id, coords);
	vec4 current_shadow = imageLoad(raytraced_shadows, coords);
	int current_object_id = int(reprojuv_and_obj_id.z);
	vec2 reprojected_uv = reprojuv_and_obj_id.xy;

	// 2x2 bilinear tap filter
	vec2 prev_coords = reprojected_uv * pfd.display_size - vec2(0.5, 0.5);
	float x = fract(prev_coords.x);
	float y = fract(prev_coords.y);
	ivec2 prev_coords_aligned = ivec2(prev_coords);

	float bilinear_weights[4] = { (1 - x) * (1 - y), x * (1 - y), (1 - x) * y, x * y };
	ivec2 offsets[4] = { ivec2(0, 0), ivec2(1, 0), ivec2(0, 1), ivec2(1, 1) };

	vec4 prev_shadow = vec4(0.0);
	float sum = 0.0;
	for(int i = 0; i < 4; ++i) {
		ivec2 sample_coords = prev_coords_aligned + offsets[i];
		if(is_valid_reprojection(sample_coords, current_object_id, current_normal)) {
			prev_shadow += bilinear_weights[i] * imageLoad(storage_images[pc.prev_frame_raytraced_shadows], sample_coords);
			sum += bilinear_weights[i];
		}
	}
	bool reprojection_valid = sum > 1e-6;
	if(reprojection_valid) {
		prev_shadow /= sum;
		imageStore(
			storage_images[pc.integrated_raytraced_shadows], 
			coords,
			current_shadow * 0.2 + prev_shadow * (1 - 0.2)
		);
		imageStore(
			denoised_raytraced_shadows, 
			coords, 
			current_shadow * 0.2 + prev_shadow * (1 - 0.2)
		);
	}
	else {
		imageStore(
			storage_images[pc.integrated_raytraced_shadows], 
			coords,
			current_shadow
		);
		imageStore(
			denoised_raytraced_shadows, 
			coords,
			current_shadow
		);
	}

//	bool valid = true;
//
//	// Reject if object ID has changed
//	int obj_id_prev = int(imageLoad(storage_images[pc.prev_frame_reprojection_uv_and_object_id], prev_coords).z);
//	if(obj_id != -1.0 && obj_id != obj_id_prev) valid = false;
//
//	if(valid) {
//		// Reject if normals aren't aligned
//		// Merge metric from [Kerzner and Salvi 2014]
//		vec4 normal_current = imageLoad(normal_texture, coords);
//		vec4 normal_prev = imageLoad(storage_images[pc.prev_frame_object_space_normals], prev_coords);
//		if(dot(normal_current, normal_prev) < cos(3.14519 / 4.0)) valid = false;
//	}
//
//	if(!valid) {
//		imageStore(denoised_raytraced_shadows, coords, vec4(1.0, 0.0, 0.0, 1.0));
//	}
//	else {
//		imageStore(denoised_raytraced_shadows, coords, vec4(0.0, 1.0, 0.0, 1.0));
//	}
//
//	imageStore(storage_images[pc.prev_frame_raytraced_shadows], coords, current_shadow);
//	imageStore(storage_images[pc.prev_frame_reprojection_uv_and_object_id], coords, reprojuv_and_obj_id);
//	imageStore(storage_images[pc.prev_frame_object_space_normals], coords, current_normal);
}
