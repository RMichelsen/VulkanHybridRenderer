#version 460
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_nonuniform_qualifier : require
#extension GL_EXT_shader_image_load_formatted : require
#include "../common.glsl"

layout(local_size_x = 8, local_size_y = 8) in;

layout(set = 1, binding = 0) uniform image2D storage_images[];

layout(set = 2, binding = 0) uniform PFD { PerFrameData pfd; };
layout(set = 3, binding = 0, r16f) readonly uniform image2D reprojected_uv_and_object_id;
layout(set = 3, binding = 1, r16f) readonly uniform image2D normal_texture;
layout(set = 3, binding = 2, r16f) readonly uniform image2D raytraced_shadows;
layout(set = 3, binding = 3, r16f) writeonly uniform image2D denoised_raytraced_shadows;

layout(push_constant) uniform PushConstants {
	int prev_frame_reprojection_uv_and_object_id;
	int prev_frame_object_space_normals;
} pc;

void main() {
	ivec2 coords = ivec2(gl_GlobalInvocationID.xy);

	vec3 reprojuv_and_obj_id = imageLoad(reprojected_uv_and_object_id, coords).xyz;
	vec2 reprojected_uv = reprojuv_and_obj_id.xy;
	ivec2 prev_coords = ivec2(reprojected_uv * pfd.display_size);

	bool reject = false;
	// Reject if normals are not similar enough
//	vec4 normal_current = imageLoad(normal_texture, coords);
//	vec4 normal_prev = imageLoad(storage_images[pc.prev_frame_object_space_normals], prev_coords);
//	if(distance(normal_current, normal_prev) > 1e-1) reject = true;

	// Reject if object ID has changed
	int obj_id = int(reprojuv_and_obj_id.z);
	int obj_id_prev = int(imageLoad(storage_images[pc.prev_frame_reprojection_uv_and_object_id], prev_coords).z);
	if(obj_id != obj_id_prev) reject = true;

	if(reject) {
		imageStore(denoised_raytraced_shadows, coords, vec4(1.0, 0.0, 0.0, 1.0));
	}
	else {
		imageStore(denoised_raytraced_shadows, coords, vec4(0.0, 1.0, 0.0, 1.0));
	}

	imageStore(storage_images[pc.prev_frame_reprojection_uv_and_object_id], coords, imageLoad(reprojected_uv_and_object_id, coords));
	imageStore(storage_images[pc.prev_frame_object_space_normals], coords, imageLoad(normal_texture, coords));
}

